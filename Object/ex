// import React, { useState, useEffect } from "react"

// //react native
// import {
//   ActivityIndicator,
//   Text,
//   View,
//   ScrollView,
//   StyleSheet,
//   Button,
//   Platform,
// } from "react-native"
// import styled from "styled-components"
// //Expo
// import Constants from "expo-constants"
// import * as Permissions from "expo-permissions"
// import { Camera } from "expo-camera"
// //Tensorflow
// import * as tf from "@tensorflow/tfjs"
// import * as mobilenet from "@tensorflow-models/mobilenet"
// import { cameraWithTensors } from "@tensorflow/tfjs-react-native"
// import * as cocossd from "@tensorflow-models/coco-ssd"
// import * as posenet from "@tensorflow-models/posenet"

// //disable yellow warnings on EXPO client!
// console.disableYellowBox = true
// //
// // const VideoBox = styled.video`
// //   position: absolute;
// //   z-index: 3;
// //   width: 450px;
// //   height: 340px;
// //   border-radius: ${(props) => props.theme.borderRadius};
// //   margin-top: 90px;
// // `

// // const CanvasBox = styled.canvas`
// //   position: absolute;
// //   z-index: 2;
// //   width: 450px;
// //   height: 340px;
// //   border-radius: ${(props) => props.theme.borderRadius};
// //   margin-top: 90px;
// // `

// //영상처리
// let time = new Date().getTime()
// let interval = 0
// let decision = [true, true, true, true, true, true]
// let detection_area = Array.from({ length: 18 }, (_, i) => i + 1)
// let finalDecision = 1 //1.공부 2. 부재중 3. 잠
// let timeCount = 0
// export default function Apps() {
//   const [predictionFound, setPredictionFound] = useState(false)
//   const [hasPermission, setHasPermission] = useState(null)

//   //Tensorflow and Permissions
//   const [modelPose, setModelPose] = useState(null)
//   const [modelDetect, setModelDetect] = useState(null)
//   const [mobilenetModel, setMobilenetModel] = useState(null)
//   const [frameworkReady, setFrameworkReady] = useState(false)

//   //defaults
//   const LoadModel = async () => {
//     console.log("ready--")

//     const loadedModelPose = await posenet.load()
//     const loadedModelDetect = await cocoSsd.load({ base: "mobilenet_v2" })
//     setModelPose(loadedModelPose)
//     setModelDetect(loadedModelDetect)
//     console.log(modelPose, "ready4")
//   }
//   //TF Camera Decorator
//   const TensorCamera = cameraWithTensors(Camera)
//   //RAF ID
//   let requestAnimationFrameId = 0

//   //performance hacks (Platform dependent)
//   const textureDims =
//     Platform.OS === "ios" ? { width: 1080, height: 1920 } : { width: 1600, height: 1200 }
//   const tensorDims = { width: 152, height: 200 }
//   function updateTime() {
//     const newTime = new Date().getTime()
//     interval = interval + (newTime - time)
//     // console.log(interval / 1000);

//     time = newTime
//   }
//   useEffect(() => {
//     if (!frameworkReady) {
//       ;(async () => {
//         //check permissions
//         const { status } = await Camera.requestPermissionsAsync()
//         console.log(`permissions status: ${status}`)
//         setHasPermission(status === "granted")
//         console.log("ready1")

//         //we must always wait for the Tensorflow API to be ready before any TF operation...
//         await tf.ready()
//         console.log("ready2")

//         //load the mobilenet model and save it in state
//         setMobilenetModel(await loadMobileNetModel())
//         console.log("ready3")
//         LoadModel()
//         console.log(modelPose, "ready4")

//         setFrameworkReady(true)
//       })()
//     }
//   }, [])

//   useEffect(() => {
//     return () => {
//       cancelAnimationFrame(requestAnimationFrameId)
//     }
//   }, [requestAnimationFrameId])

//   const loadMobileNetModel = async () => {
//     const model = await mobilenet.load()
//     return model
//   }

//   const getPrediction = async (tensor) => {
//     if (!tensor) {
//       return
//     }
//     //topk set to 1
//     const prediction = await mobilenetModel.classify(tensor, 1)

//     console.log(`${JSON.stringify(prediction)}`)

//     if (!prediction || prediction.length === 0) {
//       return
//     }
//     //only attempt translation when confidence is higher than 20%
//     if (prediction[0].probability > 0.5) {
//       //stop looping!
//       cancelAnimationFrame(requestAnimationFrameId)
//       setPredictionFound(true)
//       //get translation!
//       // await getTranslation(prediction[0].className)
//     }
//   }

//   const handleCameraStream = (imageAsTensors) => {
//     const loop = async () => {
//       updateTime()
//       const nextImageTensor = await imageAsTensors.next().value
//       await getPrediction(nextImageTensor)
//       requestAnimationFrameId = requestAnimationFrame(loop)
//     }
//     if (!predictionFound) loop()
//   }

//   return (
//     <View style={styles.container}>
//       <View style={styles.header}>
//         <Text style={styles.title}>Object</Text>
//       </View>
//       <View style={styles.body}>
//         <View style={styles.cameraView}>
//           <TensorCamera
//             style={styles.camera}
//             type={Camera.Constants.Type.front}
//             zoom={0}
//             cameraTextureHeight={textureDims.height}
//             cameraTextureWidth={textureDims.width}
//             resizeHeight={tensorDims.height}
//             resizeWidth={tensorDims.width}
//             resizeDepth={3}
//             onReady={(imageAsTensors) => handleCameraStream(imageAsTensors)}
//             autorender={true}
//           />
//         </View>
//       </View>
//     </View>
//   )
// }

// const styles = StyleSheet.create({
//   container: {
//     flex: 1,
//     justifyContent: "flex-start",
//     paddingTop: Constants.statusBarHeight,
//     backgroundColor: "#E8E8E8",
//   },
//   header: {
//     backgroundColor: "#41005d",
//   },
//   title: {
//     margin: 10,
//     fontSize: 18,
//     fontWeight: "bold",
//     textAlign: "center",
//     color: "#ffffff",
//   },
//   body: {
//     padding: 5,
//     paddingTop: 25,
//   },
//   cameraView: {
//     display: "flex",
//     flex: 1,
//     flexDirection: "column",
//     justifyContent: "flex-start",
//     alignItems: "flex-end",
//     width: "100%",
//     height: "100%",
//     paddingTop: 10,
//   },
//   camera: {
//     width: 700 / 2,
//     height: 800 / 2,
//     zIndex: 1,
//     borderWidth: 0,
//     borderRadius: 0,
//   },
//   translationView: {
//     marginTop: 30,
//     padding: 20,
//     borderColor: "#cccccc",
//     borderWidth: 1,
//     borderStyle: "solid",
//     backgroundColor: "#ffffff",
//     marginHorizontal: 20,
//     height: 500,
//   },
//   translationTextField: {
//     fontSize: 60,
//   },
//   wordTextField: {
//     textAlign: "right",
//     fontSize: 20,
//     marginBottom: 50,
//   },
//   legendTextField: {
//     fontStyle: "italic",
//     color: "#888888",
//   },
//   inputAndroid: {
//     fontSize: 16,
//     paddingHorizontal: 10,
//     paddingVertical: 8,
//     borderWidth: 1,
//     borderColor: "purple",
//     borderStyle: "solid",
//     borderRadius: 8,
//     color: "black",
//     paddingRight: 30,
//     backgroundColor: "#ffffff",
//   },
// })


//웹뷰
// import React, { useState } from "react"
// import { Button, Text, View, StyleSheet } from "react-native"
// import * as WebBrowser from "expo-web-browser"
// import Constants from "expo-constants"

// export default function Apps() {
//   const [result, setResult] = useState(null)

//   const _handlePressButtonAsync = async () => {
//     let result = await WebBrowser.openBrowserAsync("https://www.deeeeptime.com/#/study")
//     setResult(result)
//   }
//   return (
//     <View style={styles.container}>
//       <Button title="Open WebBrowser" onPress={_handlePressButtonAsync} />
//     </View>
//   )
// }

// const styles = StyleSheet.create({
//   container: {
//     flex: 1,
//     alignItems: "center",
//     justifyContent: "center",
//     paddingTop: Constants.statusBarHeight,
//     backgroundColor: "#ecf0f1",
//   },
// })
///다른거




// import React, { Component, useState, useEffect } from "react"
// import {
//   StyleSheet,
//   Text,
//   View,
//   StatusBar,
//   ActivityIndicator,
//   TouchableOpacity,
//   Image,
// } from "react-native"
// import { ScrollView } from "react-native-gesture-handler"

// import Constants from "expo-constants"
// import * as Permissions from "expo-permissions"
// import * as ImagePicker from "expo-image-picker"
// import * as FileSystem from "expo-file-system"

// import * as jpeg from "jpeg-js"

// import * as tf from "@tensorflow/tfjs"
// import "@tensorflow/tfjs-react-native"

// // import * as mobilenet from '@tensorflow-models/mobilenet'
// // You can try with other models, see https://github.com/tensorflow/tfjs-models
// import * as cocossd from "@tensorflow-models/coco-ssd"

// export default function Apps() {
//   const [isTfReady, setisTfReady] = useState(false)
//   const [isModelReady, setisModelReady] = useState(false)
//   const [predictions, setpredictions] = useState(false)
//   const [image, setimage] = useState(null)
//   const fun = async () => {
//     try {
//       await tf.ready() // preparing TensorFlow
//       setisTfReady(true)

//       // model = await mobilenet.load(); // preparing MobileNet model
//       model = await cocossd.load() // preparing COCO-SSD model
//       setisModelReady(true)

//       // getPermissionAsync() // get permission for accessing camera on mobile device
//     } catch (error) {}
//   }
//   useEffect(() => {
//     fun()
//   }, [])
//   // useEffect(async () => {
//   //   await tf.ready() // preparing TensorFlow
//   //   setisTfReady(true)

//   //   // model = await mobilenet.load(); // preparing MobileNet model
//   //   model = await cocossd.load() // preparing COCO-SSD model
//   //   setisModelReady(true)

//   //   getPermissionAsync() // get permission for accessing camera on mobile device
//   // })

//   const imageToTensor = (rawImageData) => {
//     const TO_UINT8ARRAY = true
//     const { width, height, data } = jpeg.decode(rawImageData, TO_UINT8ARRAY)
//     // Drop the alpha channel info for mobilenet
//     const buffer = new Uint8Array(width * height * 3)
//     let offset = 0 // offset into original data
//     for (let i = 0; i < buffer.length; i += 3) {
//       buffer[i] = data[offset]
//       buffer[i + 1] = data[offset + 1]
//       buffer[i + 2] = data[offset + 2]

//       offset += 4
//     }

//     return tf.tensor3d(buffer, [height, width, 3])
//   }

//   const detectObjects = async () => {
//     try {
//       const imageAssetPath = Image.resolveAssetSource(image)

//       console.log(image, imageAssetPath)
//       const imgB64 = await FileSystem.readAsStringAsync(imageAssetPath.uri, {
//         encoding: FileSystem.EncodingType.Base64,
//       })
//       const imgBuffer = tf.util.encodeString(imgB64, "base64").buffer
//       const raw = new Uint8Array(imgBuffer)
//       const imageTensor = imageToTensor(raw)
//       console.log("imageTensor: ", imageTensor)
//       const predictions = await model.detect(imageTensor)

//       setpredictions(predictions)

//       console.log("----------- predictions: ", predictions)
//     } catch (error) {
//       console.log("Exception Error: ", error)
//     }
//   }

//   const selectImage = async () => {
//     try {
//       let response = await ImagePicker.launchImageLibraryAsync({
//         mediaTypes: ImagePicker.MediaTypeOptions.All,
//         allowsEditing: true,
//         aspect: [4, 3],
//       })

//       if (!response.cancelled) {
//         const source = { uri: response.uri }
//         console.log(source, "1")
//         setimage(source)
//         console.log(image, "@")
//         detectObjects()
//       }
//     } catch (error) {
//       console.log(error)
//     }
//   }

//   /*
//   [{
//   bbox: [x, y, width, height],
//   class: "person",
//   score: 0.8380282521247864
//   }, {
//   bbox: [x, y, width, height],
//   class: "kite",
//   score: 0.74644153267145157
//   }]
//   */
//   const renderPrediction = (prediction, index) => {
//     const pclass = prediction.class
//     const score = prediction.score
//     const x = prediction.bbox[0]
//     const y = prediction.bbox[1]
//     const w = prediction.bbox[2]
//     const h = prediction.bbox[3]

//     return (
//       <Text key={index} style={styles.text}>
//         Prediction: {pclass} {", "} Probability: {score} {", "} Bbox: {x} {", "} {y} {", "} {w}{" "}
//         {", "} {h}
//       </Text>
//     )
//   }
//   // <VideoBox ref={video1} playsInline autoPlay muted /> //내부

//   return (
//     <View style={styles.container}>
//       <ScrollView style={styles.container} contentContainerStyle={styles.contentContainer}>
//         <View style={styles.welcomeContainer}>
//           <StatusBar barStyle="light-content" />
//           <View style={styles.loadingContainer}>
//             <Text style={styles.text}>TensorFlow.js ready? {isTfReady ? <Text>✌</Text> : ""}</Text>

//             <View style={styles.loadingModelContainer}>
//               <Text style={styles.text}>COCO-SSD model ready? </Text>
//               {isModelReady ? (
//                 <Text style={styles.text}>✌</Text>
//               ) : (
//                 <ActivityIndicator size="small" />
//               )}
//             </View>
//           </View>
//           <TouchableOpacity
//             style={styles.imageWrapper}
//             onPress={isModelReady ? selectImage : undefined}
//           >
//             {image && <Image source={image} style={styles.imageContainer} />}

//             {isModelReady && !image && (
//               <Text style={styles.transparentText}>Tap to choose image</Text>
//             )}
//           </TouchableOpacity>
//           <View style={styles.predictionWrapper}>
//             {isModelReady && image && (
//               <Text style={styles.text}>Predictions: {predictions ? "" : "Detecting..."}</Text>
//             )}

//             {isModelReady &&
//               predictions &&
//               predictions.map((p, index) => renderPrediction(p, index))}
//           </View>
//         </View>
//       </ScrollView>
//     </View>
//   )
// }

// Apps.navigationOptions = {
//   header: null,
// }

// const styles = StyleSheet.create({
//   container: {
//     flex: 1,
//     backgroundColor: "#171f24",
//   },
//   welcomeContainer: {
//     alignItems: "center",
//     marginTop: 10,
//     marginBottom: 20,
//   },
//   welcomeImage: {
//     width: 100,
//     height: 80,
//     resizeMode: "contain",
//     marginTop: 3,
//     marginLeft: -10,
//   },
//   contentContainer: {
//     paddingTop: 30,
//   },
//   loadingContainer: {
//     marginTop: 80,
//     justifyContent: "center",
//   },
//   text: {
//     color: "#ffffff",
//     fontSize: 16,
//   },
//   loadingModelContainer: {
//     flexDirection: "row",
//     marginTop: 10,
//   },
//   imageWrapper: {
//     width: 280,
//     height: 280,
//     padding: 10,
//     borderColor: "blue",
//     borderWidth: 5,
//     borderStyle: "dashed",
//     marginTop: 40,
//     marginBottom: 10,
//     position: "relative",
//     justifyContent: "center",
//     alignItems: "center",
//   },
//   imageContainer: {
//     width: 250,
//     height: 250,
//     position: "absolute",
//     top: 10,
//     left: 10,
//     bottom: 10,
//     right: 10,
//   },
//   predictionWrapper: {
//     height: 100,
//     width: "100%",
//     flexDirection: "column",
//     alignItems: "center",
//   },
//   transparentText: {
//     color: "#ffffff",
//     opacity: 0.7,
//   },
//   footer: {
//     marginTop: 40,
//   },
//   poweredBy: {
//     fontSize: 20,
//     color: "#e69e34",
//     marginBottom: 6,
//   },
//   tfLogo: {
//     width: 125,
//     height: 70,
//   },
// })
/////////t//




// import React, { useEffect, useState } from "react"
// import {
//   Alert,
//   StyleSheet,
//   Text,
//   View,
//   StatusBar,
//   ActivityIndicator,
//   TouchableOpacity,
//   Image,
//   ScrollView,
// } from "react-native"
// import * as tf from "@tensorflow/tfjs"
// import { fetch } from "@tensorflow/tfjs-react-native"
// import * as mobilenet from "@tensorflow-models/mobilenet"
// import * as cocoSsd from "@tensorflow-models/coco-ssd"

// import Constants from "expo-constants"
// import * as Permissions from "expo-permissions"
// import * as jpeg from "jpeg-js"
// // import { image } from "@tensorflow/tfjs"
// import * as ImagePicker from "expo-image-picker"
// import * as FileSystem from "expo-file-system"
// import { cameraWithTensors } from "@tensorflow/tfjs-react-native"
// import { Camera } from "expo-camera"

// var image = null
// // var predictions = null
// const Apps = () => {
//   const TensorCamera = cameraWithTensors(Camera)

//   const [isTfReady, setIsTfReady] = useState(false)
//   const [isModelReady, setIsModelReady] = useState(false)
//   const [predictions, setPredictions] = useState()
//   const [hasPermission, setHasPermission] = useState(null)

//   // const [image, setImage] = useState(null)
//   const [model, setModel] = useState(null)
//   const setting = async () => {
//     try {
//       await tf.ready()
//       setIsTfReady(true)
//       const model = await cocoSsd.load()
//       setModel(model)
//       setIsModelReady(true)
//       getPermissionAsync()
//     } catch (e) {
//       console.log(e)
//     }
//   }

//   const getPermissionAsync = async () => {
//     if (Constants.platform.ios) {
//       const { status } = await Permissions.askAsync(Permissions.CAMERA_ROLL)
//       if (status !== "granted") {
//         Alert.alert("Sorry, we need camera roll permissions to make this work!")
//       }
//     }
//   }
//   const imageToTensor = (rawImageData) => {
//     const TO_UINT8ARRAY = true
//     const { width, height, data } = jpeg.decode(rawImageData, TO_UINT8ARRAY)
//     // Drop the alpha channel info for mobilenet
//     const buffer = new Uint8Array(width * height * 3)
//     let offset = 0 // offset into original data
//     for (let i = 0; i < buffer.length; i += 3) {
//       buffer[i] = data[offset]
//       buffer[i + 1] = data[offset + 1]
//       buffer[i + 2] = data[offset + 2]

//       offset += 4
//     }

//     return tf.tensor3d(buffer, [height, width, 3])
//   }
//   const classifyImage = async () => {
//     try {
//       const imageAssetPath = Image.resolveAssetSource(image)
//       const response = await fetch(imageAssetPath.uri, {}, { isBinary: true })
//       const rawImageData = await response.arrayBuffer()
//       const imageTensor = imageToTensor(rawImageData)
//       const prediction = await model.detect(imageTensor)
//       setPredictions(prediction)
//       console.log(predictions)
//     } catch (error) {
//       console.log(error)
//     }
//   }

//   // const detectObjects = async () => {
//   //   try {
//   //     const imageAssetPath = Image.resolveAssetSource(image)

//   //     console.log(imageAssetPath, "imageAssetPath")
//   //     const imgB64 = await FileSystem.readAsStringAsync(imageAssetPath.uri, {
//   //       encoding: FileSystem.EncodingType.Base64,
//   //     })
//   //     const imgBuffer = tf.util.encodeString(imgB64, "base64").buffer
//   //     const raw = new Uint8Array(imgBuffer)
//   //     const imageTensor = imageToTensor(raw)
//   //     console.log("imageTensor: ", imageTensor)
//   //     const predictions = await model.detect(imageTensor)

//   //     setpredictions(predictions)

//   //     console.log("----------- predictions: ", predictions)
//   //   } catch (error) {
//   //     console.log("Exception Error: ", error)
//   //   }
//   // }
//   // const getPrediction = async (tensor) => {
//   //     if (!tensor) {
//   //       return
//   //     }
//   //     //topk set to 1
//   //     const prediction = await mobilenetModel.classify(tensor, 1)

//   //     console.log(`${JSON.stringify(prediction)}`)

//   //     if (!prediction || prediction.length === 0) {
//   //       return
//   //     }
//   //     //only attempt translation when confidence is higher than 20%
//   //     if (prediction[0].probability > 0.5) {
//   //       //stop looping!
//   //       cancelAnimationFrame(requestAnimationFrameId)
//   //       setPredictionFound(true)
//   //       //get translation!
//   //       // await getTranslation(prediction[0].className)
//   //     }
//   //   }
//   function sleep(milliseconds) {
//     const date = Date.now()
//     let currentDate = null
//     do {
//       currentDate = Date.now()
//     } while (currentDate - date < milliseconds)
//   }

//   const handleCameraStream = (imageAsTensors) => {
//     if (!imageAsTensors) {
//       console.log("Image not found!")
//     }
//     const loop = async () => {
//       const imageTensor = await imageAsTensors.next().value
//       if (model !== null) {
//         console.log("Started")
//         await getPrediction(imageTensor).catch((e) => console.log(e))
//       }
//       tf.dispose(imageAsTensors)

//       // await getPrediction(nextImageTensor)
//       requestAnimationFrameId = requestAnimationFrame(loop)
//     }
//     sleep(1000)
//     loop()
//   }
//   const [frameWorkReady, setFrameWorkReady] = useState(false)
//   useEffect(() => {
//     if (!frameWorkReady) {
//       ;(async () => {
//         const { status } = await Camera.requestPermissionsAsync().catch((e) => console.log(e))
//         // if (Platform.OS == "ios") {
//         //   setTextureDims({ height: 1920, width: 1080 })
//         // } else {
//         //   setTextureDims({ height: 1200, width: 1600 })
//         // }
//         setHasPermission(status === "granted")
//         await tf.ready().catch((e) => console.log(e))

//         setIsTfReady(true)
//         setModel(await cocoSsd.load().catch((e) => console.log(e)))
//         setIsModelReady(true)
//         getPermissionAsync()

//         setFrameWorkReady(true)
//       })()
//     }
//   }, [])

//   const selectImage = async () => {
//     try {
//       let response = await ImagePicker.launchImageLibraryAsync({
//         mediaTypes: ImagePicker.MediaTypeOptions.All,
//         allowsEditing: true,
//         aspect: [4, 3],
//       })

//       if (!response.cancelled) {
//         const source = { uri: response.uri }
//         image = source
//         classifyImage()
//         // detectObjects()
//       }
//     } catch (error) {
//       console.log(error)
//     }
//   }
//   const renderPrediction = (prediction, index) => {
//     console.log(prediction)
//     const pclass = prediction.class
//     const score = prediction.score
//     const x = prediction.bbox[0]
//     const y = prediction.bbox[1]
//     const w = prediction.bbox[2]
//     const h = prediction.bbox[3]

//     return (
//       <Text key={index} style={styles.text}>
//         Prediction: {pclass} {", "} Probability: {score} {", "} Bbox: {x} {", "} {y} {", "} {w}{" "}
//         {", "} {h}
//       </Text>
//     )
//   }
//   const textureDims =
//     Platform.OS === "ios" ? { width: 1080, height: 1920 } : { width: 1600, height: 1200 }
//   const tensorDims = { width: 152, height: 200 }

//   useEffect(() => {
//     setting()
//   })
//   return (
//     <ScrollView>
//       <View style={styles.container}>
//         <StatusBar barStyle="light-content" />
//         <View style={styles.loadingContainer}>
//           <Text style={styles.commonTextStyles}>
//             TFJS ready? {isTfReady ? <Text>✅</Text> : ""}
//           </Text>

//           <View style={styles.loadingModelContainer}>
//             <Text style={styles.text}>Model ready? </Text>
//             {isModelReady ? (
//               <Text style={styles.text}>✅</Text>
//             ) : (
//               <ActivityIndicator size="small" />
//             )}
//           </View>
//         </View>
//         <TouchableOpacity
//           style={styles.imageWrapper}
//           onPress={isModelReady ? selectImage : undefined}
//         >
//           {image && <Image source={image} style={styles.imageContainer} />}

//           {isModelReady && !image && (
//             <Text style={styles.transparentText}>Tap to choose image</Text>
//           )}
//         </TouchableOpacity>
//         <View style={styles.predictionWrapper}>
//           {isModelReady && image && (
//             <Text style={styles.text}>Predictions: {predictions ? "" : "Predicting..."}</Text>
//           )}
//           {isModelReady && predictions && predictions.map((p, index) => renderPrediction(p, index))}
//         </View>
//         <View style={styles.footer}>
//           <Text style={styles.poweredBy}>Powered by:</Text>
//         </View>
//         <View style={styles.cameraView}>
//           <TensorCamera
//             style={styles.camera}
//             type={Camera.Constants.Type.front}
//             zoom={0}
//             cameraTextureHeight={textureDims.height}
//             cameraTextureWidth={textureDims.width}
//             resizeHeight={tensorDims.height}
//             resizeWidth={tensorDims.width}
//             resizeDepth={3}
//             onReady={handleCameraStream()}
//             autorender={false}
//           />
//         </View>
//       </View>
//     </ScrollView>
//   )
// }

// const styles = StyleSheet.create({
//   container: {
//     flex: 1,
//     backgroundColor: "#171f24",
//     alignItems: "center",
//   },
//   loadingContainer: {
//     marginTop: 80,
//     justifyContent: "center",
//   },
//   text: {
//     color: "#ffffff",
//     fontSize: 16,
//   },
//   loadingModelContainer: {
//     flexDirection: "row",
//     marginTop: 10,
//   },
//   cameraView: {
//     display: "flex",
//     flex: 1,
//     flexDirection: "column",
//     justifyContent: "flex-start",
//     alignItems: "flex-end",
//     width: "100%",
//     height: "100%",
//     paddingTop: 10,
//   },
//   camera: {
//     width: 700 / 2,
//     height: 800 / 2,
//     zIndex: 1,
//     borderWidth: 0,
//     borderRadius: 0,
//   },
//   imageWrapper: {
//     width: 280,
//     height: 280,
//     padding: 10,
//     borderColor: "#cf667f",
//     borderWidth: 5,
//     borderStyle: "dashed",
//     marginTop: 40,
//     marginBottom: 10,
//     position: "relative",
//     justifyContent: "center",
//     alignItems: "center",
//   },
//   imageContainer: {
//     width: 250,
//     height: 250,
//     position: "absolute",
//     top: 10,
//     left: 10,
//     bottom: 10,
//     right: 10,
//   },
//   predictionWrapper: {
//     height: 100,
//     width: "100%",
//     flexDirection: "column",
//     alignItems: "center",
//   },
//   transparentText: {
//     color: "#ffffff",
//     opacity: 0.7,
//   },
//   footer: {
//     marginTop: 40,
//   },
//   poweredBy: {
//     fontSize: 20,
//     color: "#e69e34",
//     marginBottom: 6,
//   },
//   tfLogo: {
//     width: 125,
//     height: 70,
//   },
// })

// export default Apps